<h1>Docker and Go</h1>

<h2>Table of Contents</h2>

[TOC]

# Docker Concepts

Dockerfile ---BUILD--> Docker Image ---RUN--> Docker Container

A `Dockerfile` contains instruction to biuld a docker image using the command  `docker build`. 

The image image can be ran.

A container is a normal operating system process except that this  process is isolated and has its own file system, its own networking, and its own isolated process tree separate from the host.

To run an image inside of a container, we use the `docker run` command. It requires one parameter and that is the image name. 

# Docker Files

A Dockerfile contains instrutions required to build a Docker image

# Docker Images

## Create Image

```bash
$ docker build --tag docker-gs-ping .
```

As no tag was specified in the boave command this will create an image with the `latest` tag. To specify a tag, of say `v1.0` run

```bash
$ docker build --tag docker-gs-ping:v1.0 .
```

## List Images

View local images

```bash
$ docker image ls
```

## Rename Image

Tag images

```bash
$ docker image tag docker-gs-ping:latest docker-gs-ping:v1.0
```

## Delete image

Images are not removed but only “untagged”

```bash
$ docker image rm docker-gs-ping:v1.0
```

# Docker Multi-Stage Builds

# Docker Containers

## Run container

```bash
$ docker run docker-gs-ping
```

## Run container with exposed port

If we wanted to expose port `8080` inside the container to port `3000` outside the container, we would pass `3000:8080` to the `--publish` flag.

```bash
$ docker run --publish 8080:8080 docker-gs-ping
```

## Run container in detached mode

Use the `--detach` or `-d` for short

```bash
$ docker run -d -p 8080:8080 docker-gs-ping
```

## List running containers

```bash
$ docker ps
```

or

```bash
$ docker container list
```

Since we didn’t provide a name for the container when we started it, Docker generated a random name. This name can be seen when you list the containers

## List all containers

The default output for the `docker ps` command, is to only show running containers. If `--all` or `-a` for short is passed to the command, then all containers on our system are shown, that is stopped containers and running containers.

```bash
$ docker ps -all
```

or

```bash
$ docker container list --all
```

## Stop container

```bash
$ docker stop inspiring_ishizaka
```

## Restart container

```bash
$ docker restart inspiring_ishizaka
```

## Delete container

```bash
$ docker rm inspiring_ishizaka wizardly_joliot magical_carson gifted_mestorf
```

## Name container

To name a container, we must pass the `--name` flag to the `run` command:

```bash
$ docker run -d -p 8080:8080 --name rest-server docker-gs-ping
```

# Docker Volumes

Docker Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.

## Create a managed volume

Create a managed volume called roach

```bash
$ docker volume create roach
```

## List all managed volumes in Docker instance

```bash
$ docker volume list
```

## Remove a volume

```bash
$ docker volume rm <volume_name>
```

## List and remove all dangling volumes

```bash
$ docker volume ls -qf dangling=true
$ docker volume rm $(docker volume ls -qf dangling=true)
```

## Remove all volumes

Stop the container(s) using the following command:  	  

```bash
$ docker-compose down
```

Delete all containers using the following command:  	  

```bash
$ docker rm -f $(docker ps -a -q)
```

Delete all volumes using the following command:  	  

```bash
$ docker volume rm $(docker volume ls -q)
```

Restart the containers using the following command:  	  

```bash
$ docker-compose up -d
```


# Docker Networks

Allow Docker containers and services to communicate. See more here https://docs.docker.com/network

There are three networks, named `bridge`, `host`, and `none` that are the *default* networks and have been created by  Docker itself.

## Create a new network

Create a new bridge network called mynet

```bash
$ docker network create -d bridge mynet
```

## List all networks in a Docker instance

```bash
$ docker network list
```

# Docker Compose

For defining and running multi-container Docker applications

## Docker Compose file variables

Docker Compose allows for variable substitution

- `PGUSER=${PGUSER:-totoro}` means that inside the container, the environment variable `PGUSER` shall be set to the same value as it has on the host machine where  Docker Compose is run. If there is no environment variable with this  name on the host machine, the variable inside the container gets the  default value of `totoro`.
- `PGPASSWORD=${PGPASSWORD:?database password not set}` means that if the environment variable `PGPASSWORD` is not set on the host, Docker Compose will display an error. This is  OK, because we don’t want to hard-code default values for the password.  We set the password value in the `.env` file, which is local to our machine. It is always a good idea to add `.env` to `.gitignore` to prevent the secrets being checked into the version control.

Docker Compose will automatically read environment variables from a `.env` file if it is available.

```bash
PGPASSWORD=whatever
```

## Validate Docker Compose configuration

```bash
$ docker-compose config
```

When this command is run, Docker Compose would read the file `docker-compose.yml`, parse it into a data structure in memory, validate where possible, and print back the *reconstruction* of that configuration file from its internal representation. If this is not possible due to errors, it would print an error message instead.

## Build and run containers using Docker Compose

```bash
$ docker-compose up --build
```

- Use the `--build` flag to tell Docker to compile images before starting them
- Use the `-f`, `--file` flag for specifying the docker compose file name. If ommitted then docker compose automatically looks for a file called `docker-compose.yml`
- Use the `-p`, `--project` flag to specify the project name. If ommitted then docker compose uses the directory name for the project name
- Use the `-d`, `--detach` flag to run docker containers started by the `docker-compose`command in detached mode

## Stop containers started by Docker Compose

To stop containers started by Docker Compose and are not in detched more, press ctrl+c in the terminal where they are running

To stop containers started by Docker Compose in detched mode

```bash
$ docker-compose stop
```

## Start and remove containers started by Docker Compose

Stop and remove the containers with `docker-compose up` along with all the networks (but not volumes),  

```bash
$ docker-compose down (-v)
```

- Use `-v` flag to remove volumes

## Remove stopped containers started by Docker Compose

Remove stopped only containers, but not running containers

```bash
$ docker-compose rm [Options]
```

- Options:
  - -f, --force    Don't ask to confirm removal
  - -s, --stop.   Stop the containers, if required, before removing
  - -v                Remove any anonymous volumes attached to containers


# Connect to a Running

# Example Docker File for Go

```dockerfile
# syntax=docker/dockerfile:1

# Alpine is chosen for its small footprint
# compared to Ubuntu
# FROM golang:1.16-alpine
FROM golang:1.17.6-alpine

# Set destination for COPY
WORKDIR /app

# Download Go modules
COPY go.mod .
COPY go.sum .
RUN go mod download

# Copy the source code. Note the slash at the end, as explained in
# https://docs.docker.com/engine/reference/builder/#copy
COPY *.go ./

# Build
RUN go build -o /docker-gs-ping

# This is for documentation purposes only.
# To actually open the port, runtime parameters
# must be supplied to the docker command.
EXPOSE 8080

# (Optional) environment variable that our dockerised
# application can make use of. The value of environment
# variables can also be set via parameters supplied
# to the docker command on the command line.
#ENV HTTP_PORT=8081

# Run
# This tell docker what commands to execute when our image is used to start a container
CMD [ "/docker-gs-ping" ]

```

